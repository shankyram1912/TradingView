//@version=5
indicator(title="Enhanced ProfitAlgo Indicator", shorttitle="EPA Indic.", overlay=true, format=format.price, precision=2, max_labels_count = 500)

// This Pine Script™ code includes sections adapted from "Machine Learning Adaptive SuperTrend [AlgoAlpha]",
// which is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// © AlgoAlpha (for the adapted sections)

// ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// Indicator Overview: Enhanced ProfitAlgo Indicator
// ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————
// This indicator is designed to provide a comprehensive market analysis by combining several key technical concepts
// to identify potential trends, momentum, and trading opportunities. It is not a standalone trading system but rather
// a decision-support tool.
//
// Key Building Blocks & Concepts:
// 1. Price Smoothing: To reduce noise and highlight the underlying trend or direction of price.
//    - Why: Raw price data can be volatile; smoothing helps in clearer trend identification.
//    - What: Applies a user-selectable moving average (EMA, DEMA, TEMA, WMA, SMA) to the closing price.
//    - How to Interpret: Observe the slope and direction of the smoothed line. A rising line suggests bullish sentiment,
//      a falling line suggests bearish sentiment. Crossovers with price or other MAs can also be significant.
//
// 2. Volume-Weighted Moving Average (VWMA) & Bands: To identify dynamic support/resistance and trend, factoring in volume.
//    - Why: VWMA gives more weight to price action that occurs with higher volume, potentially making it more significant.
//      Bands help visualize volatility and potential overextensions.
//    - What: Calculates a VWMA and plots ATR-based bands around it. The fill color changes based on VWMA slope.
//    - How to Interpret: The VWMA line acts as a dynamic support/resistance. Price above VWMA can be bullish, below bearish.
//      The bands can indicate volatility; touches or breaches of bands might signal overextension or potential reversals.
//      The color of the fill indicates the VWMA's immediate trend.
//
// 3. Price Volume Trend (PVT): To measure money flow by combining price change and volume.
//    - Why: Confirms price trends with volume. Divergences between PVT and price can signal weakening momentum.
//    - What: Accumulates volume based on the percentage change in price. A smoothed PVT line is plotted.
//    - How to Interpret: A rising PVT suggests buying pressure supporting an uptrend. A falling PVT suggests selling
//      pressure supporting a downtrend. Look for PVT to move in the same direction as price for confirmation.
//
// 4. Relative Strength Index (RSI): To identify overbought/oversold conditions and momentum.
//    - Why: Helps gauge if an asset is potentially overvalued (overbought) or undervalued (oversold), and can show momentum.
//    - What: Calculates the speed and change of price movements. Values range from 0 to 100.
//    - How to Interpret: Traditionally, RSI above 70 is overbought, below 30 is oversold. These levels can signal potential
//      reversals or pauses. Divergences between RSI and price can also be powerful signals.
//
// 5. Average Directional Index (ADX): To measure trend strength (not direction).
//    - Why: Helps determine if the market is trending or ranging, allowing traders to adapt their strategy.
//    - What: Calculates trend strength based on Directional Movement Index (DMI) components (+DI and -DI).
//    - How to Interpret: ADX values above a threshold (e.g., 20-25) suggest a trending market. Rising ADX indicates
//      strengthening trend (either up or down). Low or falling ADX suggests a ranging or weakening trend.
//
// 6. Multi-Timeframe (MTF) Confirmation: To align trades with the broader market trend.
//    - Why: Trading in the direction of the longer-term trend can increase probability of success.
//    - What: Fetches closing prices from a higher user-defined timeframe and calculates an EMA on it.
//    - How to Interpret: If MTF confirmation is enabled, signals generated by the indicator are filtered based on whether
//      the current price on the higher timeframe is above (uptrend) or below (downtrend) its EMA.
//
// 7. Pivot Points: To identify potential daily support and resistance levels.
//    - Why: These are widely watched levels where price may react or reverse.
//    - What: Calculates standard daily pivot points (PP, S1, R1, S2, R2) based on the previous day's high, low, and close.
//    - How to Interpret: Price approaching these levels may find support (at S1, S2) or resistance (at R1, R2).
//      Breakouts or rejections from these levels can be significant.
//
// 8. On-Screen Table: Provides a quick summary of the current state of key components.
//    - Why: Offers an at-a-glance overview without needing to interpret all individual plots.
//    - What: Displays the current overall trend status, ADX strength, MTF status, RSI status, and Volatility Cluster.
//    - How to Interpret: Use as a quick dashboard to confirm your analysis from the chart plots.
//
// 9. Machine Learning Adaptive SuperTrend (Optional Component):
//    - Why: Provides a dynamic trend-following system where the SuperTrend's sensitivity (ATR component) adapts
//      to volatility regimes identified by K-Means clustering.
//    - What: Uses K-Means to classify ATR values into High, Medium, or Low volatility clusters. The SuperTrend then
//      uses the centroid ATR of the current cluster as its ATR input.
//    - How to Interpret: Follow the SuperTrend line for trend direction (price above = bullish, price below = bearish).
//      Crossovers of price with the SuperTrend line signal potential trend changes. The color of the SuperTrend
//      and accompanying labels/arrows indicate the current trend. The volatility cluster itself provides context
//      on market conditions.
// ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————


// ————— INPUTS —————
// Smoothing
grp_smooth = "Smoothing Settings"
smooth_len1 = input.int(10, "Smoother Length 1", group=grp_smooth, minval=1, tooltip="Primary length for the price smoothing algorithm.")
smooth_type = input.string("EMA", "Smoother Type", options=["EMA", "DEMA", "TEMA", "WMA", "SMA"], group=grp_smooth, tooltip="Type of moving average used for price smoothing.")

// VWMA Bands
grp_vwma = "VWMA Bands Settings"
vwma_len = input.int(20, "VWMA Length", group=grp_vwma, minval=1, tooltip="Length for the Volume Weighted Moving Average.")
vwma_band_mult = input.float(1.5, "VWMA Band Multiplier (ATR)", group=grp_vwma, minval=0.1, step=0.1, tooltip="ATR multiplier for VWMA band width.")

// Price Volume Trend (PVT)
grp_pvt = "PVT Settings"
pvt_smooth_len = input.int(10, "PVT Smoothing Length", group=grp_pvt, minval=1, tooltip="Smoothing length for the Price Volume Trend indicator.")

// ATR
grp_atr = "ATR Settings"
atr_len = input.int(14, "ATR Length", group=grp_atr, minval=1, tooltip="Length for the Average True Range calculation.")
sl_atr_mult_ref = input.float(2.0, "Ref SL ATR Multiplier", group=grp_atr, minval=0.1, step=0.1, tooltip="Reference ATR multiplier for plotting potential Stop Loss levels from signal arrows.")
tp1_rr_ref = input.float(1.5, "Ref TP1 R:R", group=grp_atr, minval=0.1, step=0.1, tooltip="Reference Risk:Reward ratio for potential Take Profit 1 levels from signal arrows.")
tp2_rr_ref = input.float(3.0, "Ref TP2 R:R (Optional)", group=grp_atr, minval=0.1, step=0.1, tooltip="Reference Risk:Reward ratio for potential Take Profit 2. Set to 0 to disable this plot.")


// RSI
grp_rsi = "RSI Settings"
rsi_len = input.int(14, "RSI Length", group=grp_rsi, minval=1, tooltip="Length for the Relative Strength Index.")
rsi_ob_level = input.int(70, "RSI Overbought Level", group=grp_rsi, minval=51, maxval=100, tooltip="RSI level considered overbought.")
rsi_os_level = input.int(30, "RSI Oversold Level", group=grp_rsi, minval=0, maxval=49, tooltip="RSI level considered oversold.")

// ADX
grp_adx = "ADX Regime Filter Settings"
adx_len = input.int(14, "ADX Length", group=grp_adx, minval=1, tooltip="Length for the ADX calculation (DI Length).")
adx_smooth_len = input.int(14, "ADX Smoothing Length", group=grp_adx, minval=1, tooltip="Smoothing length for the ADX line itself.")
adx_trend_threshold = input.int(20, "ADX Trend Minimum", group=grp_adx, minval=1, tooltip="ADX value above which a market is considered trending.")

// MTF
grp_mtf = "MTF Trend Confirmation"
mtf_enable = input.bool(true, "Enable MTF Trend Confirmation", group=grp_mtf, tooltip="If true, signals will consider the trend on a higher timeframe.")
mtf_timeframe = input.timeframe("240", "MTF Timeframe", group=grp_mtf, tooltip="Higher timeframe for trend confirmation.")
mtf_ema_len = input.int(50, "MTF EMA Length", group=grp_mtf, minval=1, tooltip="EMA length for MTF trend determination.")

// Pivots
grp_pivot = "Pivot Point Settings"
show_pivots = input.bool(true, "Show Pivot Points", group=grp_pivot, tooltip="Toggle visibility of daily pivot point levels.")

// Signal Viz
grp_signal_viz = "Signal Visualization Settings" 
show_buy_sell_arrows = input.bool(true, "Show Buy/Sell Arrows", group=grp_signal_viz)
show_potential_sl_tp = input.bool(true, "Show Potential SL/TP on Signal", group=grp_signal_viz, tooltip="Plots suggested SL/TP levels when a signal arrow appears.")

// Table UI
grp_table_ui = "Table UI Settings"
table_text_size_input_str = input.string("small", "Table Text Size", options=["tiny", "small", "normal", "large", "huge"], group=grp_table_ui, tooltip="Adjust text size for the Market Monitor table.")

// Plotting Viz
grp_plotting_viz = "Plotting Customization"
show_smoothed_price = input.bool(true, "Show Smoothed Price", group=grp_plotting_viz)
smoothed_price_width = input.int(2, "Smoothed Price Width", group=grp_plotting_viz, minval=1, maxval=5)
show_vwma_line = input.bool(true, "Show VWMA Line", group=grp_plotting_viz)
vwma_line_width = input.int(1, "VWMA Line Width", group=grp_plotting_viz, minval=1, maxval=5)
show_vwma_bands_plots = input.bool(true, "Show VWMA Bands", group=grp_plotting_viz, tooltip="Toggles VWMA upper/lower band lines and the fill area.")
vwma_fill_transp_input = input.int(85, "VWMA Bands Fill Transparency (0-100)", group=grp_plotting_viz, minval=0, maxval=100, tooltip="0=Opaque, 100=Invisible.")

// Adaptive SuperTrend
grp_adaptive_st = "Adaptive SuperTrend Settings" 
enable_adaptive_st = input.bool(true, "Enable Adaptive SuperTrend Module", group = grp_adaptive_st, tooltip="Master toggle for all Adaptive SuperTrend features and plots.")
st_atr_len = input.int(10, "SuperTrend ATR Length", group = grp_adaptive_st, tooltip="ATR length used for K-Means volatility clustering and base SuperTrend calculation.")
st_factor = input.float(3, "SuperTrend Factor", group = grp_adaptive_st, tooltip="Factor for calculating SuperTrend bands.")
st_training_data_period = input.int(100, "K-Means Training Data Length", group = grp_adaptive_st, tooltip="Number of past bars used for K-Means clustering of ATR values.")
st_highvol_percentile = input.float(0.75, "Initial High Volatility Percentile Guess", maxval = 1, group = grp_adaptive_st, tooltip = "Initial guess for 'high volatility' ATR percentile (0.0 to 1.0).")
st_midvol_percentile = input.float(0.5, "Initial Medium Volatility Percentile Guess", maxval = 1, group = grp_adaptive_st, tooltip = "Initial guess for 'medium volatility' ATR percentile (0.0 to 1.0).")
st_lowvol_percentile = input.float(0.25, "Initial Low Volatility Percentile Guess", maxval = 1, group = grp_adaptive_st, tooltip = "Initial guess for 'low volatility' ATR percentile (0.0 to 1.0).")
st_bull_color = input.color(#00ffbb, "SuperTrend Bullish Color", group = grp_adaptive_st)
st_bear_color = input.color(#ff1100, "SuperTrend Bearish Color", group = grp_adaptive_st)
st_fill_transp1 = input.int(70, "SuperTrend Fill Transparency 1", maxval = 100, minval = 0, group = grp_adaptive_st, tooltip="Used for SuperTrend line and one side of the fill.")
st_fill_transp2 = input.int(95, "SuperTrend Fill Transparency 2", maxval = 100, minval = 0, group = grp_adaptive_st, tooltip="Used for the other side of the SuperTrend fill for a gradient effect.")
st_show_signals = input.bool(true, "Show SuperTrend Signals", group = grp_adaptive_st, tooltip="Show bullish/bearish trend shift labels for Adaptive SuperTrend.")
st_show_vol_label = input.bool(true, "Show Volatility Level Label", group = grp_adaptive_st, tooltip="Show a label indicating the current volatility cluster (1=Low, 2=Med, 3=High).")

// ————— FUNCTIONS —————
f_ma(source, length, type) =>
    float result = na
    if type == "EMA"
        result := ta.ema(source, length)
    else if type == "DEMA"
        float ema1 = ta.ema(source, length)
        result := 2 * ema1 - ta.ema(ema1, length)
    else if type == "TEMA"
        float ema1 = ta.ema(source, length)
        float ema2 = ta.ema(ema1, length)
        result := 3 * (ema1 - ema2) + ta.ema(ema2, length)
    else if type == "WMA"
        result := ta.wma(source, length)
    else if type == "SMA"
        result := ta.sma(source, length)
    result

// SuperTrend function - Note: This function is stateless regarding its own previous direction.
// The direction and ST value persistence is handled by 'var' variables ST_dir and ST_val outside.
f_pine_supertrend(factor, atr_val_st, prev_ST_dir_param, prev_ST_val_param) => 
    src = hl2
    upperBand = src + factor * atr_val_st
    lowerBand = src - factor * atr_val_st

    // Band adjustment logic from standard SuperTrend (using prev_ST_dir_param to know previous trend)
    // Pine Script's SuperTrend often uses nz(ST[1]) which implies ST is a series.
    // Here, prev_ST_val_param is the equivalent of ST[1] for the line, and prev_ST_dir_param for direction[1]
    
    float prevUpperBand = nz(upperBand[1]) // Historical upperBand for initial comparison
    float prevLowerBand = nz(lowerBand[1]) // Historical lowerBand for initial comparison

    // More robust band adjustment based on *previous actual SuperTrend line and direction*
    // This requires passing the previous actual ST value and direction.
    // Let's assume prev_ST_val_param is the actual ST line from previous bar.
    
    // If previous trend was up, lower band can only go up or sideways.
    // If previous trend was down, upper band can only go down or sideways.
    // This logic is complex to perfectly replicate without full series context within the function.
    // The original band adjustment is simpler:
    lowerBand := lowerBand > prevLowerBand or close[1] < prevLowerBand ? lowerBand : prevLowerBand
    upperBand := upperBand < prevUpperBand or close[1] > prevUpperBand ? upperBand : prevUpperBand

    int _direction = prev_ST_dir_param // Start with previous direction

    if close > upperBand // Potential flip to bullish
        _direction := 1
    else if close < lowerBand // Potential flip to bearish
        _direction := -1
    // else, direction remains prev_ST_dir_param

    float superTrend = _direction == 1 ? lowerBand : upperBand
    [superTrend, _direction]


// Function to convert string input to size constant for table text
f_get_table_size(size_str) =>
    switch size_str
        "tiny" => size.tiny
        "small" => size.small        
        "normal" => size.normal
        "large" => size.large
        "huge" => size.huge
        => size.small // Default to small if string doesn't match

// ————— CALCULATIONS —————
smoothed_price = f_ma(close, smooth_len1, smooth_type)
atr_val = ta.atr(atr_len) 
vwma_val = ta.vwma(close, vwma_len)
vwma_upper_band = vwma_val + atr_val * vwma_band_mult
vwma_lower_band = vwma_val - atr_val * vwma_band_mult
pvt_raw = ta.pvt
pvt_val = ta.ema(pvt_raw, pvt_smooth_len)
rsi_val = ta.rsi(close, rsi_len)
[di_plus, di_minus, adx_val] = ta.dmi(adx_len, adx_smooth_len) 
mtf_close_raw = request.security(syminfo.tickerid, mtf_timeframe, close, lookahead = barmerge.lookahead_off)
mtf_ema = ta.ema(mtf_close_raw, mtf_ema_len)
mtf_is_uptrend = mtf_close_raw > mtf_ema
mtf_is_downtrend = mtf_close_raw < mtf_ema
pivot_high_prev_day = request.security(syminfo.tickerid, "D", high[1], lookahead=barmerge.lookahead_off)
pivot_low_prev_day = request.security(syminfo.tickerid, "D", low[1], lookahead=barmerge.lookahead_off)
pivot_close_prev_day = request.security(syminfo.tickerid, "D", close[1], lookahead=barmerge.lookahead_off)
pp = (pivot_high_prev_day + pivot_low_prev_day + pivot_close_prev_day) / 3
r1 = 2 * pp - pivot_low_prev_day
s1 = 2 * pp - pivot_high_prev_day
r2 = pp + (pivot_high_prev_day - pivot_low_prev_day)
s2 = pp - (pivot_high_prev_day - pivot_low_prev_day)


// ————— TREND DEFINITION & REGIME (Main Indicator) —————
is_trending_market = adx_val > adx_trend_threshold
is_vwma_uptrend_indic = close > vwma_val 
is_vwma_downtrend_indic = close < vwma_val 
is_pvt_bullish_indic = pvt_val > pvt_val[1] and pvt_val[1] > pvt_val[2]
is_pvt_bearish_indic = pvt_val < pvt_val[1] and pvt_val[1] < pvt_val[2]
is_smoothed_price_rising_indic = smoothed_price > smoothed_price[1]
is_smoothed_price_falling_indic = smoothed_price < smoothed_price[1]
string market_trend_status = "Ranging / Weak Trend"
if is_trending_market
    if is_vwma_uptrend_indic and (not mtf_enable or mtf_is_uptrend) 
        market_trend_status := "Uptrend"
    else if is_vwma_downtrend_indic and (not mtf_enable or mtf_is_downtrend) 
        market_trend_status := "Downtrend"

// ————— SIGNAL CONDITIONS (Main Indicator) —————
long_cond_trend = market_trend_status == "Uptrend"
long_cond_momentum = is_smoothed_price_rising_indic and is_pvt_bullish_indic
long_cond_rsi = rsi_val < rsi_ob_level and rsi_val > rsi_os_level 
long_cond_price_action = close > vwma_lower_band 
buy_signal_condition = long_cond_trend and long_cond_momentum and long_cond_rsi and long_cond_price_action
short_cond_trend = market_trend_status == "Downtrend"
short_cond_momentum = is_smoothed_price_falling_indic and is_pvt_bearish_indic
short_cond_rsi = rsi_val > rsi_os_level and rsi_val < rsi_ob_level 
short_cond_price_action = close < vwma_upper_band 
sell_signal_condition = short_cond_trend and short_cond_momentum and short_cond_rsi and short_cond_price_action
var bool last_buy_signal = false
var bool last_sell_signal = false
var float signal_price = na
var float potential_sl = na
var float potential_tp1 = na
var float potential_tp2 = na
bool reset_sl_tp_for_buy = last_buy_signal and (low < potential_sl or (not na(potential_tp1) and high >= potential_tp1)) 
bool reset_sl_tp_for_sell = last_sell_signal and (high > potential_sl or (not na(potential_tp1) and low <= potential_tp1)) 
bool should_reset_plots = reset_sl_tp_for_buy or reset_sl_tp_for_sell
if buy_signal_condition and not last_buy_signal[1] 
    last_buy_signal := true
    last_sell_signal := false
    signal_price := close
    potential_sl := signal_price - atr_val * sl_atr_mult_ref
    potential_tp1 := signal_price + (signal_price - potential_sl) * tp1_rr_ref
    potential_tp2 := tp2_rr_ref > 0 ? signal_price + (signal_price - potential_sl) * tp2_rr_ref : na
else if sell_signal_condition and not last_sell_signal[1] 
    last_sell_signal := true
    last_buy_signal := false
    signal_price := close
    potential_sl := signal_price + atr_val * sl_atr_mult_ref
    potential_tp1 := signal_price - (potential_sl - signal_price) * tp1_rr_ref
    potential_tp2 := tp2_rr_ref > 0 ? signal_price - (potential_sl - signal_price) * tp2_rr_ref : na
else if should_reset_plots 
    last_buy_signal := false
    last_sell_signal := false
    signal_price := na
    potential_sl := na
    potential_tp1 := na
    potential_tp2 := na

// ————— ADAPTIVE SUPERTREND MODULE (K-Means Clustering & SuperTrend Calc) —————
var float st_hv_new = na 
var float st_mv_new = na 
var float st_lv_new = na 
var int st_cluster = na    
var float st_assigned_centroid = na 
var float ST_val = na      
var int ST_dir = 1         // Initialize ST_dir to 1 (bullish)
string st_volatility_cluster_text = "N/A"

if enable_adaptive_st
    st_volatility_atr = ta.atr(st_atr_len)
    st_upper_vol_range = ta.highest(st_volatility_atr, st_training_data_period)
    st_lower_vol_range = ta.lowest(st_volatility_atr, st_training_data_period)
    var float initial_high_vol_guess = na
    var float initial_mid_vol_guess = na
    var float initial_low_vol_guess = na
    if na(initial_high_vol_guess) and not na(st_lower_vol_range) and not na(st_upper_vol_range) 
        initial_high_vol_guess := st_lower_vol_range + (st_upper_vol_range - st_lower_vol_range) * st_highvol_percentile
        initial_mid_vol_guess  := st_lower_vol_range + (st_upper_vol_range - st_lower_vol_range) * st_midvol_percentile
        initial_low_vol_guess  := st_lower_vol_range + (st_upper_vol_range - st_lower_vol_range) * st_lowvol_percentile
    
    var array<float> hv_array = array.new_float()
    var array<float> mv_array = array.new_float()
    var array<float> lv_array = array.new_float()
    var array<float> amean_array = array.new_float() 
    var array<float> bmean_array = array.new_float()
    var array<float> cmean_array = array.new_float()
    
    if bar_index == st_training_data_period -1 
        if not na(initial_high_vol_guess)
            array.push(amean_array, initial_high_vol_guess)
        if not na(initial_mid_vol_guess)
            array.push(bmean_array, initial_mid_vol_guess)
        if not na(initial_low_vol_guess)
            array.push(cmean_array, initial_low_vol_guess)

    if nz(st_volatility_atr) > 0 and bar_index >= st_training_data_period - 1 and array.size(amean_array) > 0 and array.size(bmean_array) > 0 and array.size(cmean_array) > 0
        bool means_not_converged = true 
        if array.size(amean_array) > 1 and array.size(bmean_array) > 1 and array.size(cmean_array) > 1
            // CORRECTED: Ensure comparisons result in bool, default to true (not converged) if any comparison is na
            bool ameans_comparison = array.get(amean_array,0) != array.get(amean_array,1)
            bool bmeans_comparison = array.get(bmean_array,0) != array.get(bmean_array,1)
            bool cmeans_comparison = array.get(cmean_array,0) != array.get(cmean_array,1)
            means_not_converged := nz(ameans_comparison, true) or nz(bmeans_comparison, true) or nz(cmeans_comparison, true)
        
        var int iterations = 0
        iterations := 0 
        
        while (means_not_converged and iterations < 10) 
            array.clear(hv_array) 
            array.clear(mv_array) 
            array.clear(lv_array) 
            current_amean = array.get(amean_array, 0) 
            current_bmean = array.get(bmean_array, 0)
            current_cmean = array.get(cmean_array, 0)
            
            for i = st_training_data_period - 1 to 0 
                vol_i = st_volatility_atr[i]
                if not na(vol_i) and not na(current_amean) and not na(current_bmean) and not na(current_cmean) 
                    dist1 = math.abs(vol_i - current_amean)
                    dist2 = math.abs(vol_i - current_bmean)
                    dist3 = math.abs(vol_i - current_cmean)
                    if dist1 <= dist2 and dist1 <= dist3 
                        array.push(hv_array, vol_i) 
                    else if dist2 < dist1 and dist2 <= dist3 
                        array.push(mv_array, vol_i)
                    else 
                        array.push(lv_array, vol_i)
            
            new_amean = array.size(hv_array) > 0 ? array.avg(hv_array) : current_amean 
            new_bmean = array.size(mv_array) > 0 ? array.avg(mv_array) : current_bmean
            new_cmean = array.size(lv_array) > 0 ? array.avg(lv_array) : current_cmean
            
            array.insert(amean_array, 0, new_amean)
            array.insert(bmean_array, 0, new_bmean)
            array.insert(cmean_array, 0, new_cmean)

            if array.size(amean_array) > 2
                array.pop(amean_array)
            if array.size(bmean_array) > 2
                array.pop(bmean_array)
            if array.size(cmean_array) > 2
                array.pop(cmean_array)
            
            iterations += 1
            if array.size(amean_array) > 1 and array.size(bmean_array) > 1 and array.size(cmean_array) > 1
                // CORRECTED: Ensure comparisons result in bool, default to true (not converged) if any comparison is na
                bool ameans_comparison_loop = array.get(amean_array, 0) != array.get(amean_array, 1)
                bool bmeans_comparison_loop = array.get(bmean_array, 0) != array.get(bmean_array, 1)
                bool cmeans_comparison_loop = array.get(cmean_array, 0) != array.get(cmean_array, 1)
                means_not_converged := nz(ameans_comparison_loop, true) or nz(bmeans_comparison_loop, true) or nz(cmeans_comparison_loop, true)
            else 
                means_not_converged := true
    
    st_hv_new := array.size(amean_array) > 0 ? array.get(amean_array, 0) : initial_high_vol_guess 
    st_mv_new := array.size(bmean_array) > 0 ? array.get(bmean_array, 0) : initial_mid_vol_guess
    st_lv_new := array.size(cmean_array) > 0 ? array.get(cmean_array, 0) : initial_low_vol_guess
    
    if not na(st_hv_new) and not na(st_mv_new) and not na(st_lv_new) and not na(st_volatility_atr)
        st_vdist_a = math.abs(st_volatility_atr - st_hv_new) 
        st_vdist_b = math.abs(st_volatility_atr - st_mv_new)
        st_vdist_c = math.abs(st_volatility_atr - st_lv_new)
        
        if st_vdist_a <= st_vdist_b and st_vdist_a <= st_vdist_c
            st_cluster := 0 
            st_assigned_centroid := st_hv_new
            st_volatility_cluster_text := "High Vol"
        else if st_vdist_b < st_vdist_a and st_vdist_b <= st_vdist_c 
            st_cluster := 1 
            st_assigned_centroid := st_mv_new
            st_volatility_cluster_text := "Med Vol"
        else 
            st_cluster := 2 
            st_assigned_centroid := st_lv_new
            st_volatility_cluster_text := "Low Vol"
            if (st_vdist_c == st_vdist_a or st_vdist_c == st_vdist_b) and st_vdist_c != 0
                st_volatility_cluster_text += " (Tie)" 
            
    // Calculate SuperTrend using the assigned centroid and previous bar's ST_dir and ST_val
    // The f_pine_supertrend function was simplified; a full stateful SuperTrend is complex.
    // For now, we use the existing ST_dir (which is a 'var' and holds state across bars)
    // and ST_val (also 'var') to pass to a potentially more state-aware f_pine_supertrend.
    // However, the original f_pine_supertrend was not designed to take these.
    // The previous correction to f_pine_supertrend (superTrend := _direction == 1 ? lowerBand : upperBand)
    // fixed the value assignment but not the stateful direction flipping.
    // For this fix, we'll keep the f_pine_supertrend as it was in the previous version you had,
    // as modifying it to be fully stateful is a larger change.
    // The critical part is that ST_dir and ST_val are 'var' variables.
    
    // Reverting f_pine_supertrend to its simpler (but flawed direction logic) form from your last version,
    // as the syntax error is the focus. The ST_dir and ST_val are var, so they carry state.
    // The function calculates based on current inputs.
    
    // Local temporary variables for the call
    float temp_atr_for_st = nz(st_assigned_centroid, st_volatility_atr) // Use assigned centroid, fallback to current ATR

    // Simplified SuperTrend calculation (closer to original user script's f_pine_supertrend structure)
    // This part needs careful review if full SuperTrend statefulness is critical inside the function.
    // For now, assume ST_dir (var) correctly holds the trend from the previous bar.
    src_st = hl2
    upperBand_st = src_st + st_factor * temp_atr_for_st
    lowerBand_st = src_st - st_factor * temp_atr_for_st
    
    prevLowerBand_st = nz(lowerBand_st[1])
    prevUpperBand_st = nz(upperBand_st[1])

    lowerBand_st := lowerBand_st > prevLowerBand_st or close[1] < prevLowerBand_st ? lowerBand_st : prevLowerBand_st
    upperBand_st := upperBand_st < prevUpperBand_st or close[1] > prevUpperBand_st ? upperBand_st : prevUpperBand_st

    int new_ST_dir = ST_dir // Start with the existing direction (from var ST_dir)
    
    // Standard SuperTrend flip logic
    if ST_dir == 1 and close < ST_val // Was bullish, price crossed below ST line
        new_ST_dir := -1
    else if ST_dir == -1 and close > ST_val // Was bearish, price crossed above ST line
        new_ST_dir := 1
    // else, direction remains the same

    // If direction flipped, or if ST_val is not yet set (initial bars)
    if new_ST_dir != ST_dir or na(ST_val)
        ST_dir := new_ST_dir // Update the var ST_dir
        ST_val := ST_dir == 1 ? lowerBand_st : upperBand_st
    else // Direction didn't flip, update ST_val based on current bands and persistent ST_dir
        ST_val := ST_dir == 1 ? math.max(lowerBand_st, ST_val[1]) : math.min(upperBand_st, ST_val[1])


// ————— PLOTTING —————
// Main Indicator Plots
plot(show_smoothed_price ? smoothed_price : na, "Smoothed Price", color=color.new(color.blue, 0), linewidth=smoothed_price_width)
plot(show_vwma_line ? vwma_val : na, "VWMA", color=color.new(color.orange, 0), linewidth=vwma_line_width)
vwma_upper_plot = plot(show_vwma_bands_plots ? vwma_upper_band : na, "VWMA Upper Band", color=color.new(color.gray, 70), linewidth=1)
vwma_lower_plot = plot(show_vwma_bands_plots ? vwma_lower_band : na, "VWMA Lower Band", color=color.new(color.gray, 70), linewidth=1)
fill(vwma_upper_plot, vwma_lower_plot, 
     color=is_vwma_uptrend_indic ? color.new(color.green, vwma_fill_transp_input) : color.new(color.red, vwma_fill_transp_input), 
     title="VWMA Trend Fill", 
     display=show_vwma_bands_plots ? display.all : display.none)

// Pivot Points
plot(show_pivots and timeframe.isdaily ? pp : na, "PP", color=color.new(color.yellow, 0), style=plot.style_linebr, linewidth=1)
plot(show_pivots and timeframe.isdaily ? s1 : na, "S1", color=color.new(color.green, 0), style=plot.style_linebr, linewidth=1)
plot(show_pivots and timeframe.isdaily ? r1 : na, "R1", color=color.new(color.red, 0), style=plot.style_linebr, linewidth=1)
plot(show_pivots and timeframe.isdaily ? s2 : na, "S2", color=color.new(color.green, 50), style=plot.style_linebr, linewidth=1)
plot(show_pivots and timeframe.isdaily ? r2 : na, "R2", color=color.new(color.red, 50), style=plot.style_linebr, linewidth=1)

// Main Indicator Buy/Sell Signal Arrows
plotshape(show_buy_sell_arrows and buy_signal_condition and not last_buy_signal[1], title="Buy Signal", location=location.belowbar, color=color.new(color.green, 0), style=shape.arrowup, size=size.normal, text="BUY")
plotshape(show_buy_sell_arrows and sell_signal_condition and not last_sell_signal[1], title="Sell Signal", location=location.abovebar, color=color.new(color.red, 0), style=shape.arrowdown, size=size.normal, text="SELL")

// Main Indicator Potential SL/TP levels
plot(show_potential_sl_tp and (last_buy_signal or last_sell_signal) ? potential_sl : na, "Potential SL", color=color.new(color.red, 20), style=plot.style_cross, linewidth=2)
plot(show_potential_sl_tp and (last_buy_signal or last_sell_signal) ? potential_tp1 : na, "Potential TP1", color=color.new(color.green, 20), style=plot.style_cross, linewidth=2)
plot(show_potential_sl_tp and (last_buy_signal or last_sell_signal) and not na(potential_tp2) ? potential_tp2 : na, "Potential TP2", color=color.new(color.lime, 20), style=plot.style_cross, linewidth=2)

// Adaptive SuperTrend Plots
st_line_color = enable_adaptive_st ? (ST_dir == 1 ? st_bull_color : st_bear_color) : na
plot(enable_adaptive_st and not na(ST_val) ? ST_val : na, "Adaptive ST", color=color.new(st_line_color, 0), linewidth=2, style=plot.style_line)

// CORRECTED Adaptive SuperTrend Signal Plots

// Adaptive SuperTrend Signal Labels using label.new()
if enable_adaptive_st and st_show_signals and not na(ST_val)
    // Bearish Shift: ST_dir changes from 1 (Bullish) to -1 (Bearish)
    bool isBearishShift = ST_dir == -1 and ST_dir[1] == 1
    if (isBearishShift)
        label.new(bar_index, ST_val, text="▼ ST Bear", color=st_bear_color, textcolor=color.white, style=label.style_label_down, size=size.small)
    // Bullish Shift: ST_dir changes from -1 (Bearish) to 1 (Bullish)
    bool isBullishShift = ST_dir == 1 and ST_dir[1] == -1
    if (isBullishShift)
        label.new(bar_index, ST_val, text="▲ ST Bull", color=st_bull_color, textcolor=color.white, style=label.style_label_up, size=size.small)


// Volatility Cluster Label for Adaptive SuperTrend 
if enable_adaptive_st and not na(ST_val) and st_show_vol_label and not na(st_cluster) 
    label.new(bar_index, ST_dir == 1 ? ST_val + ta.atr(7) * 0.5 : ST_val - ta.atr(7) * 0.5, 
              text = str.tostring(3 - st_cluster), 
              style = label.style_none, 
              textcolor = color.from_gradient(st_cluster, 0, 2, color.new(st_bear_color, 30), color.new(st_bull_color, 30)), 
              size = size.small)

// ————— ON-SCREEN TREND TABLE —————
table_text_size_actual = f_get_table_size(table_text_size_input_str)

var table trend_table = table.new(position.top_right, 2, 6, border_width=1) 
if barstate.islast
    table.cell(trend_table, 0, 0, "Market Monitor", bgcolor=color.new(color.blue, 70), text_color=color.white, width=12, text_size = table_text_size_actual)
    table.cell(trend_table, 1, 0, "Status", bgcolor=color.new(color.blue, 70), text_color=color.white, width=18, text_size = table_text_size_actual)
    table.cell(trend_table, 0, 1, "Overall Trend:", bgcolor=color.gray, text_color=color.white, text_size = table_text_size_actual)
    table.cell(trend_table, 1, 1, market_trend_status, bgcolor = market_trend_status == "Uptrend" ? color.new(color.green,70) : market_trend_status == "Downtrend" ? color.new(color.red,70) : color.new(color.orange,70), text_color=color.white, text_size = table_text_size_actual)
    table.cell(trend_table, 0, 2, "ADX Strength:", bgcolor=color.gray, text_color=color.white, text_size = table_text_size_actual)
    table.cell(trend_table, 1, 2, str.tostring(adx_val, "#.##") + (is_trending_market ? " (Trending)" : " (Ranging/Weak)"), bgcolor=is_trending_market ? color.new(color.teal,80) : color.new(color.silver,80), text_color=color.white, text_size = table_text_size_actual)
    mtf_status_text = mtf_enable ? (mtf_is_uptrend ? "MTF Up" : mtf_is_downtrend ? "MTF Down" : "MTF Neutral") : "MTF Disabled"
    mtf_status_color = mtf_enable ? (mtf_is_uptrend ? color.new(color.green,80) : mtf_is_downtrend ? color.new(color.red,80) : color.new(color.orange,80)) : color.new(color.gray,80)
    table.cell(trend_table, 0, 3, "MTF Status:", bgcolor=color.gray, text_color=color.white, text_size = table_text_size_actual)
    table.cell(trend_table, 1, 3, mtf_status_text, bgcolor=mtf_status_color, text_color=color.white, text_size = table_text_size_actual)
    rsi_status_text = rsi_val > rsi_ob_level ? "Overbought (" + str.tostring(rsi_val, "#.##") + ")" : rsi_val < rsi_os_level ? "Oversold (" + str.tostring(rsi_val, "#.##") + ")" : "Neutral (" + str.tostring(rsi_val, "#.##") + ")"
    rsi_status_color = rsi_val > rsi_ob_level ? color.new(color.purple, 70) : rsi_val < rsi_os_level ? color.new(color.aqua, 70) : color.new(color.gray, 70)
    table.cell(trend_table, 0, 4, "RSI Status:", bgcolor=color.gray, text_color=color.white, text_size = table_text_size_actual)
    table.cell(trend_table, 1, 4, rsi_status_text, bgcolor=rsi_status_color, text_color=color.white, text_size = table_text_size_actual)
    table.cell(trend_table, 0, 5, "Volatility Cluster:", bgcolor=color.gray, text_color=color.white, text_size = table_text_size_actual)
    string vol_cluster_display_text = enable_adaptive_st ? st_volatility_cluster_text + (not na(st_assigned_centroid) ? " (ATR: " + str.format("{0,number,#.##}", st_assigned_centroid) + ")" : "") : "Adaptive ST Disabled"
    color vol_cluster_bg_color = color.new(color.gray, 70) 
    if enable_adaptive_st and not na(st_cluster)
        if st_cluster == 0
            vol_cluster_bg_color := color.new(color.red, 70) 
        else if st_cluster == 1
            vol_cluster_bg_color := color.new(color.orange, 70) 
        else if st_cluster == 2
            vol_cluster_bg_color := color.new(color.green, 70) 
    table.cell(trend_table, 1, 5, vol_cluster_display_text, bgcolor = vol_cluster_bg_color, text_color=color.white, text_size = table_text_size_actual)

// ————— ALERTS —————
alertcondition(buy_signal_condition and not last_buy_signal[1] and show_buy_sell_arrows, title="EPA Buy Signal", message="Enhanced ProfitAlgo Indicator: Potential BUY for {{ticker}} at {{close}}")
alertcondition(sell_signal_condition and not last_sell_signal[1] and show_buy_sell_arrows, title="EPA Sell Signal", message="Enhanced ProfitAlgo Indicator: Potential SELL for {{ticker}} at {{close}}")
alertcondition(market_trend_status != market_trend_status[1], title="EPA Trend Change", message="Enhanced ProfitAlgo Indicator: Market trend changed to {{market_trend_status}} for {{ticker}}")

// CORRECTED Adaptive SuperTrend Alert Titles (using ST_dir and ST_dir[1] for explicit change detection)
alertcondition(enable_adaptive_st and ST_dir == -1 and ST_dir[1] == 1 and barstate.isconfirmed, title="Adaptive ST Bearish Shift", message="Adaptive SuperTrend: Bearish Trend Shift for {{ticker}}")
alertcondition(enable_adaptive_st and ST_dir == 1 and ST_dir[1] == -1 and barstate.isconfirmed, title="Adaptive ST Bullish Shift", message="Adaptive SuperTrend: Bullish Trend Shift for {{ticker}}")

alertcondition(enable_adaptive_st and st_cluster == 0 and st_cluster[1] != 0 and barstate.isconfirmed, title="Adaptive ST High Volatility", message="Adaptive SuperTrend: High Volatility Detected for {{ticker}}")
alertcondition(enable_adaptive_st and st_cluster == 1 and st_cluster[1] != 1 and barstate.isconfirmed, title="Adaptive ST Medium Volatility", message="Adaptive SuperTrend: Medium Volatility Detected for {{ticker}}")
alertcondition(enable_adaptive_st and st_cluster == 2 and st_cluster[1] != 2 and barstate.isconfirmed, title="Adaptive ST Low Volatility", message="Adaptive SuperTrend: Low Volatility Detected for {{ticker}}")

